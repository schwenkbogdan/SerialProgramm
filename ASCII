0x40 @
0x47 G
0x55 U
0x49 I

0x4f 0x4b 0x40 OK@
0x4f 0x4b 0x40

0xd 0xa 0x57 0x65 0x6c 0x63 0x6f 0x6d 0x65 0x20 0x74 0x6f 0x20 0x50 0x72 0x6f 0x74 0x65 0x6b 0x20 0x33 0x32 0x30 0x31 0x4e 0xd 0xa 0x47 0x53 0x49 0x6e 0x73
Read 32: 0x74 0x72 0x75 0x6d 0x65 0x6e 0x74 0x73 0xd 0xa 0x68 0x6d 0x6b 0x6f 0x6e 0x67 0x40 0x67 0x73 0x69 0x6e 0x73 0x74 0x72 0x75 0x6d 0x65 0x6e 0x74 0x2e 0x63 0x6f
Read 3: 0x6d 0xd 0xa



Это означало, что этот софт ставит какие-то дополнительные флаги, которая моя программа не
ставила. И на помощь пришла утилита stty. Получаем параметры порта до запуска cutecom,
после инициализации моей программой и после запуска. Смотрим разницу:
stty -a -F /dev/ttyUSB0 > first
cutecom^C
stty -a -F /dev/ttyUSB0 > second
diff first second
В результате оказалось, что программа cutecom снимает флаг ISIG и устанавливает
флаг IGNBRK. Так что даже на этапе отладки бывают подставы.

struct termios {

 tcflag_t c_iflag; /* флаги режима ввода */

 tcflag_t c_oflag; /* флаги режима вывода */

 tcflag_t c_cflag; /* флаги управляющего режима */

 tcflag_t c_lflag; /* флаги локального режима */

 cc_t c_line;      /* дисциплина линии связи */

 cc_t c_cc[NCCS];  /* управляющие символы */

};